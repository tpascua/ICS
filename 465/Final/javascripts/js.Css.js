// Generated by CoffeeScript 1.8.0
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.js == null) {
    window.js = {};
  }

  window.js.Css = (function() {
    var key, _i, _j, _len, _len1, _ref, _ref1;

    function Css() {}

    Css.arounds = ['top', 'right', 'bottom', 'left'];

    Css.aroudRules = ['margin', 'padding', 'border-width', 'border-color'];

    Css.rules = {
      numeric: ['top', 'left', 'margin', 'padding', 'border-width'],
      colors: ['color', 'background-color', 'border-color']
    };

    Css.noPx = function(pixels) {
      return Math.round(pixels.replace('px', ''));
    };

    Css.addPx = function(pixels) {
      return "" + pixels + (pixels === 0 ? '' : 'px');
    };

    Css.same = function(value) {
      return value;
    };

    Css.hexColor = function(value) {
      var bytes, number;
      bytes = (function() {
        var _i, _len, _ref, _results;
        _ref = value.match(/(\d+) *, *(\d+) *, *(\d+)/).slice(1, 4);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          number = _ref[_i];
          number = Number(number);
          _results.push("" + (number < 16 ? '0' : '') + (number.toString(16)));
        }
        return _results;
      })();
      return "#" + (bytes.join(''));
    };

    Css.from = {};

    Css.to = {};

    _ref = Css.rules.numeric;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      Css.from[key] = Css.noPx;
      Css.to[key] = Css.addPx;
    }

    _ref1 = Css.rules.colors;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      key = _ref1[_j];
      Css.from[key] = Css.hexColor;
      Css.to[key] = Css.same;
    }

    Css.css = function(element, key, values) {
      var fromCss, key_, prefix, property, split, suffix, toCss, _k, _len2, _ref2, _ref3, _ref4;
      split = function() {
        var prefix, suffix, _ref2;
        _ref2 = key.split('-'), prefix = _ref2[0], suffix = _ref2[1];
        suffix = suffix != null ? "-" + suffix : '';
        return [prefix, suffix];
      };
      if (values != null) {
        toCss = Css.to[key];
        if (__indexOf.call(Css.aroudRules, key) >= 0) {
          _ref2 = split(), prefix = _ref2[0], suffix = _ref2[1];
          _ref3 = Css.arounds;
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            key_ = _ref3[_k];
            element.css("" + prefix + "-" + key_ + suffix, toCss(values[key_]));
            lAdd("" + prefix + "-" + key_ + suffix, toCss(values[key_]));
          }
          log("" + (element.attr('id')) + " set");
          return element;
        } else {
          return element.css(key, toCss(values));
        }
      } else {
        fromCss = Css.from[key];
        if (__indexOf.call(Css.aroudRules, key) >= 0) {
          _ref4 = split(), prefix = _ref4[0], suffix = _ref4[1];
          property = function(key_) {
            return fromCss(element.css("" + prefix + "-" + key_ + suffix));
          };
          log("" + (element.attr('id')) + " get", js.Support.filled(Css.arounds, property));
          return js.Support.filled(Css.arounds, property);
        } else {
          return fromCss(element.css(key));
        }
      }
    };

    Css.shrink = function(values) {
      var key_, value, value_;
      value = values.top;
      for (key_ in values) {
        value_ = values[key_];
        if (value_ !== value) {
          return values;
        }
      }
      return value;
    };

    Css.toArounds = function(values) {
      var i;
      if (js.Support.type(values) === 'Array') {
        values = (function() {
          var _k, _results;
          switch (values.length) {
            case 0:
              return [0, 0, 0, 0];
            case 1:
              _results = [];
              for (i = _k = 1; _k <= 4; i = ++_k) {
                _results.push(values[0]);
              }
              return _results;
              break;
            case 2:
              return values.concat(values);
            case 3:
              return values.concat(values[1]);
            default:
              return values;
          }
        })();
        return js.Support.filled(Css.arounds, function(key, index) {
          return values[index];
        });
      } else {
        return values;
      }
    };

    Css.expand = function(value) {
      return js.Support.filled(Css.arounds, function() {
        return value;
      });
    };

    return Css;

  })();


  /*
  cd "/Users/jan/Documents/workspace/465/3_media/"
  coffee -cwo javascripts/ coffeescripts/
   */

}).call(this);
